####READ ME

课外时间翻阅 C++ primer 5th ，记录下学习的历程
顺便写写课后习题 或者 写写小程序

* 写了下linux下进程间通信的几种实现方式:
    * 共享内存的方式,也就是mmap()函数来设置共享内存的大小以及访问的权限
    之类的属性,返回的值就是系统生成的p_map的addr地址值，只要多个进程保持
    mapping的状态，就可以通过p_map的值来访问共享内存里面的值，以及通过memcpy
    函数来修改共享内存区域的值，影响到多个进程读取对应的变量的实际值
    * pipe 管道对于两端的进程而言就是一个特殊的文件(仅存于内存之中)
        * 管道是单向的也就是所谓的"半双工"，故双向通信需要两个管道.
        * 限制: 
            * 只能应用于父子 兄弟进程之间的通信(因为没有名字)
            * 管道的写端对读端的依赖:写端写入数据的时候必须要正有一个读端是
            畅通的,否则导致pipe broken异常
            * 管道的写端如果关闭了,读端默认读取的都是0
            * 写操作不保证原子性 ->每次的写入字节数最好大于 4096
        * 管道数据的读取就如队列 FIFO
        * PIPE_BUFFER 的大小在不同内核有不同的容量: 512 / 4096 字节
        * fork() 返回值是一个pid_t类型的宏包含了两个值。如果出错返回-1,生成的子进程
        返回值为0 而父进程返回的值是子进程的pid
    * 消息队列实现进程通信
        * 
    * 信号量机制 : 安装信号 处理信号 发送信号
        * kill(pid_t pid,int signo) 也就是kill掉指定id的process,原则如下:
            * pid > 0 就是kill掉指定的id进程
            * pid = 0 就是kill掉同一个进程组的进程
            * pid < 0 && pid != -1 kill掉进程组id为-pid的所有进程
            * pid = -1 除了发送kill()的进程外所有进程ID>0的进程都要被kill掉。
            * signo 是一个信号值 如果signo = 0 表示发送一个空信号但是系统还是会错误检查
            虽然除此之外不做任何其他的事务，故用来做进程是否存在或者是进程是否含有给对应进程
            发送信号的权限检测是不错的选择。
            
* 关于函数传参的几个方式导致实参的变化:
    * 形参的类型影响着形参和实参的交互方式:
        * 如果说形参的类型是引用的话,那么形参就和实参绑定在一起成为了实参的一个别名,导致的直接
        结果就是修改形参的val同时耶影响到了实参的val
        * 通过参数的引用可以绑定实参的原则 可以实现一个函数"返回"多个val的效果，使用参数引用的
        形式还可以避免copy一份实参再赋值给形参。
    * 形参是否被const修饰:
        * 两个相同的函数具有一致的签名信息但是唯一不同的是参数列表里面的参数多了const
        修饰符,会导致编译不通过的,因为在编译的时候会自动的忽略掉const修饰符号,这就形成
        了两个相同签名信息的method自然无法通过。
        * 尽量在参数列表中尝试常亮引用:
            * 之前说过,在想要让一个函数返回/影响 多个值给调用者的情况下可以采用传递普通
            变量的引用给函数，然后在函数中return返回值的同时也修改与实参绑定在一起的形参
            然而这样的需求不是普遍的,大多数的情况下实参是不希望被修改到本身的value的,所以
            就建议开发者尽量的传递实参的常量引用,这样传值给函数的同时又保证了自身不会被修改。
            * 
        * 数组传递问题:
            * 数组是不能够copy给另外一个数组的,所以从值传递这个角度对于数组来说是不行的,只
            能考虑从指针传递
            * 但是如果函数使用数组指针形参的话如何知道数组的大小呢?
                * 参考string遇到'\0'就结束的方式,给数组添加一个项作为结束的指标
                * 参考标准库的做法,给函数传递数组的首指针和尾指针,只要begin!=end,就可以
                一直遍历下去。
                * 最简单的就是在参数列表里面添加一个指明数组的长度的int参数
        * 什么是内联函数 ？
            * 优点: 函数调用到值的返回经历了寄存器cpu计算等work相对直接的三元操作来说
            是要慢一些的,而此时如果给函数添加一个inline标志,那么函数内容就直接被是作为
            三元操作而不是走函数栈的流程,优化了的结果,尤其适合规模小,流程直接,频繁调用的函数
            
    * 使用struct 和 class 的不同情景:
        * struct的目的在于分享,所以所有的成员变量都是public
        * 而class的目的只是自身或者child使用,所以把成员变量都设置为private
        * 可见 唯一的区别就是访问控制的权限不一样.