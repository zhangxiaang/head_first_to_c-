####READ ME

课外时间翻阅 C++ primer 5th ，记录下学习的历程
顺便写写课后习题 或者 写写小程序

* 写了下linux下进程间通信的几种实现方式:
    * 共享内存的方式,也就是mmap()函数来设置共享内存的大小以及访问的权限
    之类的属性,返回的值就是系统生成的p_map的addr地址值，只要多个进程保持
    mapping的状态，就可以通过p_map的值来访问共享内存里面的值，以及通过memcpy
    函数来修改共享内存区域的值，影响到多个进程读取对应的变量的实际值
    * pipe 管道对于两端的进程而言就是一个特殊的文件(仅存于内存之中)
        * 管道是单向的也就是所谓的"半双工"，故双向通信需要两个管道.
        * 限制: 
            * 只能应用于父子 兄弟进程之间的通信(因为没有名字)
            * 管道的写端对读端的依赖:写端写入数据的时候必须要正有一个读端是
            畅通的,否则导致pipe broken异常
            * 管道的写端如果关闭了,读端默认读取的都是0
            * 写操作不保证原子性 ->每次的写入字节数最好大于 4096
        * 管道数据的读取就如队列 FIFO
        * PIPE_BUFFER 的大小在不同内核有不同的容量: 512 / 4096 字节
        * fork() 返回值是一个pid_t类型的宏包含了两个值。如果出错返回-1,生成的子进程
        返回值为0 而父进程返回的值是子进程的pid
    * 消息队列实现进程通信
        * 
    * 信号量机制 : 安装信号 处理信号 发送信号
        * kill(pid_t pid,int signo) 也就是kill掉指定id的process,原则如下:
            * pid > 0 就是kill掉指定的id进程
            * pid = 0 就是kill掉同一个进程组的进程
            * pid < 0 && pid != -1 kill掉进程组id为-pid的所有进程
            * pid = -1 除了发送kill()的进程外所有进程ID>0的进程都要被kill掉。
            * signo 是一个信号值 如果signo = 0 表示发送一个空信号但是系统还是会错误检查
            虽然除此之外不做任何其他的事务，故用来做进程是否存在或者是进程是否含有给对应进程
            发送信号的权限检测是不错的选择。